Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 

Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.
 

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?


# Solution
Let’s solve the Two Sum problem in Python using a one-pass approach. Given an array of integers nums and a target value, we want to find the indices of two numbers in the array that add up to the target. Here’s an efficient one-pass solution using a dictionary:

Python
```
def two_sum(nums, target):
    num_to_index = {}  # Dictionary to store each element and its index
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_to_index:
            return [num_to_index[complement], i]
        num_to_index[num] = i
    raise ValueError("No two sum solution")

# Example usage
nums1 = [2, 7, 11, 15]
target1 = 9
print(two_sum(nums1, target1))  # Output: [0, 1]

nums2 = [3, 2, 4]
target2 = 6
print(two_sum(nums2, target2))  # Output: [1, 2]
```

In this solution:

We iterate through the array once.
For each element, we calculate its complement (target minus the element).
If the complement exists in our dictionary, we return the indices of the two elements.
Otherwise, we add the current element and its index to the dictionary.
If no solution is found, we raise an exception.
This approach has a time complexity of O(n) and is more efficient than the brute-force method.
